## 语言设计原理

### uintptr和unsafe.Pointer的区别

unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；

而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；

unsafe.Pointer 可以和 普通指针 进行相互转换；

unsafe.Pointer 可以和 uintptr 进行相互转换。

### GC

可以配合[undergo](/public/series/dev/go/undergo.md#垃圾回收-garbage-collection)

[ref](https://www.yuque.com/aceld/golang/zhzanb)

标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题。

- STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)；
- 标记需要扫描整个heap；
- 清除数据会产生heap碎片。

**Go V1.3** 做了简单的优化,将STW的步骤提前, 减少STW暂停的时间范围

**将STW的步骤提前了一步**，因为在Sweep清除的时候，可以不需要STW停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题。

**没有STW的三色标记法会出现错误**

**Go V1.5**

可以看出，有两种情况，在三色标记法中，是不希望被发生的。

- 条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)
- 条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)
如果当以上两个条件同时满足时，就会出现对象丢失现象!

插入屏障与删除屏障对栈上对象不会生效

- 插入写屏障：黑色节点新引用到白色节点前，把白色节点变为灰色
- 删除写屏障：灰色节点删除到白色节点的引用时，把白色节点变成灰色节点

插入写屏障不足：结束时需要STW来重新扫描栈
删除写屏障不足：回收精度低，需要下一次回收才能回收掉被删除引用的白色垃圾对象

>疑问：栈按理说不应该进行GC，为什么会扫描栈空间？如果栈指针引用了堆上的对象，那不还是按照堆对象进行gc吗？和栈有什么关系？还是说栈指针引用了堆对象后，需要对该栈帧进行扫描，但是不使用屏障

上述猜想是正确的，这里的栈对象本身还是在堆上，只是被栈上指针引用，GO的gc会扫描栈来找到栈指针指向的堆对象，来确定引用关系

**Go V1.8**

插入写屏障和删除写屏障的短板：

- 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活； 
- 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。 

Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。

1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，

2、GC期间，任何在栈上创建的新对象，均为黑色。

3、被删除的对象标记为灰色。

4、被添加的对象标记为灰色。

满足: 变形的弱三色不变式.


### GMP

可以配合[undergo](/public/series/dev/go/undergo.md#gmp-gpm)

[ref](https://www.yuque.com/aceld/golang/zhzanb)

调度器策略:

1）work stealing机制

当本线程无可运行的G时，先尝试全局队列，再尝试从其他线程绑定的P偷取G，而不是销毁线程。

2）hand off机制

当本线程因为G进行**系统调用阻塞**时，线程释放绑定的P，把P转移给其他空闲的线程执行。

场景:

创建goroutine时，可能创建在本地队列中，满足局部性，如果满了，会分割队列，拿出队列前面的一半打乱放入全局队列

>局部性，同一个核有l1,l2 cache，分配到同一个线程容易命中，提高执行效率

也可能会唤醒其他M，分配到那个M

自旋线程就是M对应的P本地队列没有要执行的协程，但是该线程是运行状态

偷取其他P的G时，也是分割队列，取后一半

#### m0 g0

m0是第一个线程，在全局变量runtime.m0中，不分配在堆上

g0是每个m的绑定的唯一goroutine，负责goroutine调度

## GO语言精进之路

### GMP

Go从1.5版本开始将P的默认数量由1改为CPU核的数量(实际上还乘了每个核上硬线程数量)

#### I/O

Go运行时已经实现了**netpoller**，这使得即便G发起网络I/O操作也不会导致M被阻塞（仅阻塞G），因而不会导致大量线程（M）被创建出来。但是对于常规文件的I/O操作一旦阻塞，那么线程（M）将进入挂起状态，等待I/O返回后被唤醒。这种情况下P将与挂起的M分离，再选择一个处于空闲状态（idle）的M。如果此时没有空闲的M，则会新创建一个M（线程），这就是大量文件I/O操作会导致大量线程被创建的原因。

Go开发团队的Ian Lance Taylor在Go 1.9版本中增加了一个针对文件I/O的Poller，它可以像netpoller那样，在G操作那些支持监听的（pollable）文件描述符时，仅阻塞G，而不会阻塞M。**不过该功能依然对常规文件无效，常规文件是不支持监听的**。但对于goroutine调度器而言，这也算是一个不小的进步了。

#### 抢占式调度

栈增长抢占：

原理是在每个函数或方法的入口加上一段额外的代码，让运行时有机会检查是否需要执行抢占调度。

这种协作式抢占调度的解决方案只是局部解决了“饿死”问题，对于没有函数调用而是纯算法循环计算的G，goroutine调度器依然无法抢占

异步抢占：

但Go 1.14版本中加入了**基于系统信号的goroutine抢占式调度机制**，上述问题被解决

---

运行时间过长被调度：

可以看出，如果一个G任务运行超过10ms，sysmon就会认为其运行时间太久而发出抢占式调度的请求。一旦G的抢占标志位被设为true，那么在这个G下一次调用函数或方法时，运行时便可以将G抢占并移出运行状态，放入P的本地运行队列中（如果P的本地运行队列已满，那么将放在全局运行队列中），等待下一次被调度。

channel阻塞或网络I/O情况下的调度:

如果G被阻塞在某个channel操作或网络I/O操作上，那么G会被放置到某个等待队列中，而M会尝试运行P的下一个可运行的G。如果此时P没有可运行的G供M运行，那么M将解绑P，并进入挂起状态。当I/O操作完成或channel操作完成，在等待队列中的G会被唤醒，标记为runnable（可运行），并被放入某个P的队列中，绑定一个M后继续执行。

系统调用阻塞情况下的调度:

如果G被阻塞在某个系统调用上，**那么不仅G会阻塞，执行该G的M也会解绑P（实质是被sysmon抢走了），与G一起进入阻塞状态**。如果此时有空闲的M，则P会与其绑定并继续执行其他G；如果没有空闲的M，但仍然有其他G要执行，那么就会创建一个新M（线程）。当系统调用返回后，阻塞在该系统调用上的G会尝试获取一个可用的P，如果有可用P，之前运行该G的M将绑定P继续运行G；如果没有可用的P，那么G与M之间的关联将解除，同时G会被标记为runnable，放入全局的运行队列中，等待调度器的再次调度

##### sysmon

监控线程sysmon由main goroutine创建，不是工作线程，不受GPM模型管理，不需要P，以g0执行一系列重复任务

sysmon每20us~10ms启动一次，主要完成如下工作:

- 释放闲置超过5 分钟的 span 物理内存； 
- 如果超过2 分钟没有垃圾回收，强制执⾏； 
- 将⻓时间未处理的 netpoll 添加到全局队列； 
- 向⻓时间运⾏的 G 任务发出抢占调度(超过10ms的 g，会进⾏ retake)；
- 收回因 syscall ⻓时间阻塞的 P；

### 几种并发模型

**传统的并发模型**

多线程编程，采用**共享内存**的方式，加锁解锁资源

**基于消息的并发模型**

Actor: 
- 消息是直接发送到对方的，没有中介
- 消息的收发是异步的，类似邮箱

CSP:
- 消息是发送到channel的，不区分发送者与接收者对象是谁
- 消息的收发是同步的，或者有限异步

它们都是描述独立的流程通过消息传递进行通信 主要的区别在于：在CSP消息交换是同步的(即两个流程的执行"接触点"的，在此他们交换消息)，而Actor模型是完全解耦的，可以在任意的时间将消息发送给任何未经证实的接受者。

由于Actor享有更大的相互独立,因为他可以根据自己的状态选择处理哪个传入消息。自主性更大些。

在Go语言中为了不堵塞流程，程序员必须检查不同的传入消息，以便预见确保正确的顺序。CSP好处是Channel不需要缓冲消息，而Actor理论上需要一个无限大小的邮箱作为消息缓冲